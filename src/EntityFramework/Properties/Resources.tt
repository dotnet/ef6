<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".cs" #>
<#

var parameterMatcher = new Regex(@"\{(\d)\}");
var lines = new List<Tuple<string, string, string, bool, string, string>>();

using (var resxReader = new ResXResourceReader(Path.ChangeExtension(Host.TemplateFile, "resx")))
{
    resxReader.UseResXDataNodes = true;

    foreach (DictionaryEntry entry in resxReader)
    {
        var node = (ResXDataNode)entry.Value;
        var value = (string)node.GetValue((System.ComponentModel.Design.ITypeResolutionService)null);

        var matchedArgs
            = parameterMatcher.Matches(value)
                .Cast<Match>()
                .Select(m => Convert.ToInt32(m.Groups[1].Value))
                .ToArray();
            
        var argGenerator
            = new object[matchedArgs.Any() ? matchedArgs.Max() + 1 : 0];

        lines.Add(Tuple.Create<string, string, string, bool, string, string>(
                node.Name, 
                value, 
                node.Comment.StartsWith("## ExceptionType=") ? node.Comment.Substring(17) : null,
                argGenerator.Any(),
                string.Join(", ", argGenerator.Select((_, i) => "p" + i)),
                "(" + string.Join(", ", argGenerator.Select((_, i) => "object p" + i)) + ")"
            ));
    }
}

string outputNamespace = Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint") ?? string.Empty;
#>
// <auto-generated />

namespace <#= outputNamespace #>.Resources
{
    using System.CodeDom.Compiler;
    using System.Globalization;
    using System.Resources;
    using System.Threading;

    /// <summary>
    /// Strongly-typed and parameterized string resources.
    /// </summary>
    [GeneratedCode("<#= Path.GetFileName(Host.TemplateFile) #>", "1.0.0.0")]
    internal static class Strings
    {<#
        foreach (var line in lines)
        {
        #>

        /// <summary>
        /// A string like "<#= line.Item2 #>"
        /// </summary>
        internal static string <#= line.Item1 #><#= line.Item4 ? line.Item6 : string.Empty #>
        {
            <#
            if (!line.Item4)
            {
            #>get { return EntityRes.GetString(EntityRes.<#= line.Item1 #>); }
<#
            }
            else
            {
            #>return EntityRes.GetString(EntityRes.<#= line.Item1 #>, <#= line.Item5 #>);
<#
            }#>
        }
<#
        }#>
    }

    /// <summary>
    /// Strongly-typed and parameterized exception factory.
    /// </summary>
    [GeneratedCode("<#= Path.GetFileName(Host.TemplateFile) #>", "1.0.0.0")]
    internal static class Error
    {<#
        foreach (var line in lines.Where(l => l.Item3 != null))
        {
#>

        /// <summary>
        /// <#= line.Item3 #> with message like "<#= line.Item2 #>"
        /// </summary>
        internal static Exception <#= line.Item1 #><#= line.Item4 ? line.Item6 : "()" #>
        {
            return new <#= line.Item3 #>(Strings.<#= line.Item1 #><#= line.Item4 ? "(" + line.Item5 + ")" : string.Empty #>);
        }
<#
        }#>

        /// <summary>
        /// The exception that is thrown when the value of an argument is outside the allowable range of values as defined by the invoked method.
        /// </summary>
        internal static Exception ArgumentOutOfRange(string paramName)
        {
            return new ArgumentOutOfRangeException(paramName);
        }

        /// <summary>
        /// The exception that is thrown when the author has yet to implement the logic at this point in the program. This can act as an exception based TODO tag.
        /// </summary>
        internal static Exception NotImplemented()
        {
            return new NotImplementedException();
        }

        /// <summary>
        /// The exception that is thrown when an invoked method is not supported, or when there is an attempt to
        /// read, seek, or write to a stream that does not support the invoked functionality.
        /// </summary>
        internal static Exception NotSupported()
        {
            return new NotSupportedException();
        }
    }

    /// <summary>
    /// AutoGenerated resource class. Usage:
    /// string s = EntityRes.GetString(EntityRes.MyIdenfitier);
    /// </summary>
    [GeneratedCode("<#= Path.GetFileName(Host.TemplateFile) #>", "1.0.0.0")]
    internal sealed class EntityRes
    {
<#
        foreach (var line in lines)
        {
#>        internal const string <#= line.Item1 #> = "<#= line.Item1 #>";
<#
        }
        #>

        private static EntityRes loader;
        private readonly ResourceManager resources;

        private EntityRes()
        {
            resources = new ResourceManager(
                "System.Data.Entity.Properties.<#= Path.GetFileNameWithoutExtension(Host.TemplateFile) #>", typeof(System.Data.Entity.DbContext).Assembly);
        }

        private static EntityRes GetLoader()
        {
            if (loader == null)
            {
                var sr = new EntityRes();
                Interlocked.CompareExchange(ref loader, sr, null);
            }
            return loader;
        }

        private static CultureInfo Culture
        {
            get { return null /*use ResourceManager default, CultureInfo.CurrentUICulture*/; }
        }

        public static ResourceManager Resources
        {
            get { return GetLoader().resources; }
        }

        public static string GetString(string name, params object[] args)
        {
            var sys = GetLoader();
            if (sys == null)
            {
                return null;
            }

            var res = sys.resources.GetString(name, Culture);

            if (args != null
                && args.Length > 0)
            {
                for (var i = 0; i < args.Length; i ++)
                {
                    var value = args[i] as String;
                    if (value != null
                        && value.Length > 1024)
                    {
                        args[i] = value.Substring(0, 1024 - 3) + "...";
                    }
                }
                return String.Format(CultureInfo.CurrentCulture, res, args);
            }
            else
            {
                return res;
            }
        }

        public static string GetString(string name)
        {
            var sys = GetLoader();
            if (sys == null)
            {
                return null;
            }
            return sys.resources.GetString(name, Culture);
        }

        public static string GetString(string name, out bool usedFallback)
        {
            // always false for this version of gensr
            usedFallback = false;
            return GetString(name);
        }

        public static object GetObject(string name)
        {
            var sys = GetLoader();
            if (sys == null)
            {
                return null;
            }
            return sys.resources.GetObject(name, Culture);
        }
    }
}
